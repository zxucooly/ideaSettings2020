<application>
  <component name="AppStorage">
    <histories>
      <item value="&lt;p&gt;Note: great care must be exercised if mutable objects are used as map * keys. The behavior of a map is not specified if the value of an object is * changed in a manner that affects &lt;tt&gt;equals&lt;/tt&gt; comparisons while the * object is a key in the map. A special case of this prohibition is that it * is not permissible for a map to contain itself as a key. While it is * permissible for a map to contain itself as a value, extreme caution is * advised: the &lt;tt&gt;equals&lt;/tt&gt; and &lt;tt&gt;hashCode&lt;/tt&gt; methods are no longer * well defined on such a map." />
      <item value="exercised" />
      <item value="great care must be exercised if mutable objects are used as map * keys." />
      <item value="obsolete" />
      <item value="* &lt;p&gt;This interface takes the place of the &lt;tt&gt;Dictionary&lt;/tt&gt; class, which * was a totally abstract class rather than an interface." />
      <item value="5" />
      <item value="Toggles the endianness of the specified 32-bit integer." />
      <item value="UDT" />
      <item value="Channel Handler Context" />
      <item value="explicit" />
      <item value="integration" />
      <item value="intergration" />
      <item value="cuisine" />
      <item value="commodity" />
      <item value="member" />
      <item value="shell" />
      <item value="Factorial" />
      <item value="Reflective Matcher" />
      <item value="Reflective" />
      <item value="lenient" />
      <item value="datum" />
      <item value="ratio" />
      <item value="Angle" />
      <item value="ha safety helmet" />
      <item value="hassafetyhelmet" />
      <item value="Field" />
      <item value="Filed" />
      <item value="prescribed" />
      <item value="delivered" />
      <item value="Delivered" />
      <item value="desired" />
      <item value="Rendezvous" />
      <item value="service activator" />
      <item value="Indicates that a method is capable of handling a message or message payload." />
      <item value="inbound" />
      <item value="retained" />
      <item value="Bussiness" />
      <item value="Noise" />
      <item value="successor" />
      <item value="Cancels an ongoing attempt to acquire." />
      <item value="* Various flavors of acquire, varying in exclusive/shared and * control modes. Each is mostly the same, but annoyingly * different. Only a little bit of factoring is possible due to * interactions of exception mechanics (including ensuring that we * cancel if tryAcquire throws exception) and other control, at * least not without hurting performance too much." />
      <item value="Try the fast path of enq; backup to full enq on failure" />
      <item value="exclusive Owner Thread" />
      <item value="Performs" />
      <item value="barge" />
      <item value="estimated" />
      <item value="Funnel" />
      <item value="Funnels" />
      <item value="While the scoping mechanism for {@code synchronized} methods * and statements makes it much easier to program with monitor locks, * and helps avoid many common programming errors involving locks, * there are occasions where you need to work with locks in a more * flexible way. For example, some algorithms for traversing * concurrently accessed data structures require the use of * &amp;quot;hand-over-hand&amp;quot; or &amp;quot;chain locking&amp;quot;: you * acquire the lock of node A, then node B, then release A and acquire * C, then release B and acquire D and so on. Implementations of the * {@code Lock} interface enable the use of such techniques by * allowing a lock to be acquired and released in different scopes, * and allowing multiple locks to be acquired and released in any * order." />
      <item value="The use of {@code synchronized} methods or statements provides * access to the implicit monitor lock associated with every object, but * forces all lock acquisition and release to occur in a block-structured way: * when multiple locks are acquired they must be released in the opposite * order, and all locks must be released in the same lexical scope in which * they were acquired." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="145" />
        <entry key="ENGLISH" value="146" />
        <entry key="ESTONIAN" value="1" />
        <entry key="GERMAN" value="1" />
        <entry key="FRENCH" value="2" />
        <entry key="FINNISH" value="1" />
        <entry key="LUXEMBOURGISH" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="SLOVENIAN" value="1" />
        <entry key="HINDI" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>