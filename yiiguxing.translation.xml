<application>
  <component name="AppStorage">
    <histories>
      <item value="datum" />
      <item value="ratio" />
      <item value="Angle" />
      <item value="ha safety helmet" />
      <item value="hassafetyhelmet" />
      <item value="Field" />
      <item value="Filed" />
      <item value="prescribed" />
      <item value="delivered" />
      <item value="Delivered" />
      <item value="desired" />
      <item value="Rendezvous" />
      <item value="service activator" />
      <item value="Indicates that a method is capable of handling a message or message payload." />
      <item value="inbound" />
      <item value="retained" />
      <item value="Bussiness" />
      <item value="Noise" />
      <item value="successor" />
      <item value="Cancels an ongoing attempt to acquire." />
      <item value="* Various flavors of acquire, varying in exclusive/shared and * control modes. Each is mostly the same, but annoyingly * different. Only a little bit of factoring is possible due to * interactions of exception mechanics (including ensuring that we * cancel if tryAcquire throws exception) and other control, at * least not without hurting performance too much." />
      <item value="Try the fast path of enq; backup to full enq on failure" />
      <item value="exclusive Owner Thread" />
      <item value="Performs" />
      <item value="barge" />
      <item value="estimated" />
      <item value="Funnel" />
      <item value="Funnels" />
      <item value="While the scoping mechanism for {@code synchronized} methods * and statements makes it much easier to program with monitor locks, * and helps avoid many common programming errors involving locks, * there are occasions where you need to work with locks in a more * flexible way. For example, some algorithms for traversing * concurrently accessed data structures require the use of * &amp;quot;hand-over-hand&amp;quot; or &amp;quot;chain locking&amp;quot;: you * acquire the lock of node A, then node B, then release A and acquire * C, then release B and acquire D and so on. Implementations of the * {@code Lock} interface enable the use of such techniques by * allowing a lock to be acquired and released in different scopes, * and allowing multiple locks to be acquired and released in any * order." />
      <item value="The use of {@code synchronized} methods or statements provides * access to the implicit monitor lock associated with every object, but * forces all lock acquisition and release to occur in a block-structured way: * when multiple locks are acquired they must be released in the opposite * order, and all locks must be released in the same lexical scope in which * they were acquired." />
      <item value="statements" />
      <item value="They allow more flexible structuring, may have * quite different properties, and may support multiple associated * {@link Condition} objects." />
      <item value="Lock} implementations provide more extensive locking * operations than can be obtained using {@code synchronized} methods * and statements. They allow more flexible structuring, may have * quite different properties, and may support multiple associated * {@link Condition} objects." />
      <item value="circumstances" />
      <item value="lies dormant" />
      <item value="If the lock is not available then the current thread becomes * disabled for thread scheduling purposes and lies dormant until the * lock has been acquired." />
      <item value="thread scheduling purposes" />
      <item value="excess" />
      <item value="set" />
      <item value="enum" />
      <item value="广域网" />
      <item value="is Descending" />
      <item value="DESC" />
      <item value="判断" />
      <item value="transient" />
      <item value="positive" />
      <item value="Runnable" />
      <item value="Hand" />
      <item value="reinstate Headless Property" />
      <item value="Indicates the dependency is optional for use of this library. While the version of the dependency will be taken into account for dependency calculation if the library is used elsewhere, it will not be passed on transitively." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="131" />
        <entry key="ENGLISH" value="131" />
        <entry key="ESTONIAN" value="1" />
        <entry key="GERMAN" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="FINNISH" value="1" />
        <entry key="LUXEMBOURGISH" value="1" />
        <entry key="SLOVENIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>